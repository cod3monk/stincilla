fn iteration1f1i[T](out: Img, arr: Img,
                    bh_lower: fn(i32, i32, i32, fn(T)) -> i32, bh_upper: fn(i32, i32, i32, fn(T)) -> i32,
                    body: fn(i32, i32, Acc, Acci16[T]) -> ()
                   ) -> () {
    let out_acc = get_acc(out);
    let arr_acc = get_acci16_bh[T](arr, 10, bh_lower, bh_upper);

    for benchmark_cpu() {
        for y in $outer_loop(0, out.height) {
            for x in inner_loop(0, out.width) @{
                body(x, y, out_acc, arr_acc);
            }
        }
    }
}
fn iteration2i[T](out: Img, arr: Img,
                  bh_lower: fn(i32, i32, i32, fn(T)) -> i32, bh_upper: fn(i32, i32, i32, fn(T)) -> i32,
                  body: fn(i32, i32, Acci16[T], Acci16[T]) -> ()
                 ) -> () {
    let out_acc = get_acci16[T](out);
    let arr_acc = get_acci16_bh[T](arr, 10, bh_lower, bh_upper);

    for benchmark_cpu() {
        for y in $outer_loop(0, out.height) {
            for x in inner_loop(0, out.width) @{
                body(x, y, out_acc, arr_acc);
            }
        }
    }
}
fn iteration2i1m[T](out: Img, img: Img, map: Img,
                    bh_lower: fn(i32, i32, i32, fn(T)) -> i32, bh_upper: fn(i32, i32, i32, fn(T)) -> i32,
                    body: fn(i32, i32, Acci16[T], Acci16[T], Acc) -> ()
                   ) -> () {
    let out_acc = get_acci16[T](out);
    let img_acc = get_acci16_bh[T](img, 10, bh_lower, bh_upper);
    let map_acc = get_acc(map);

    for benchmark_cpu() {
        for y in $outer_loop(0, out.height) {
            for x in inner_loop(0, out.width) @{
                body(x, y, out_acc, img_acc, map_acc);
            }
        }
    }
}
fn iteration3i[T](out: Img, img: Img, tmp: Img,
                  body: fn(i32, i32, Acci16[T], Acci16[T], Acci16[T]) -> ()
                 ) -> () {
    let out_acc = get_acci16[T](out);
    let img_acc = get_acci16[T](img);
    let tmp_acc = get_acci16[T](tmp);

    for benchmark_cpu() {
        for y in $outer_loop(0, out.height) {
            for x in inner_loop(0, out.width) @{
                body(x, y, out_acc, img_acc, tmp_acc);
            }
        }
    }
}
fn reduce[T](img: Img, body: fn(i32, i32, Acci16[T]) -> i32) -> i32 {
    let mut sum = 0;
    let img_acc = get_acci16[T](img);
    for y in $range(0, img.height) {
        for x in inner_loop(0, img.width) @{
            sum += body(x, y, img_acc);
        }
    }
    sum
}
fn histogram(img: Img, body: fn(i32, i32, Acc) -> i32) -> Buffer {
    let hist_buf = alloc_cpu(256 * sizeof[i32]());
    let mut hist = bitcast[&[i32]](hist_buf.data);
    let img_acc  = get_acc(img);

    for i in $range(0, 256) {
        hist(i) = 0;
    }
    for y in $range(0, img.height) {
        for x in range(0, img.width) @{
            let bin = body(x, y, img_acc);
            hist(bin)++;
        }
    }

    hist_buf
}
fn inclusive_scan(hist_buf: Buffer, size: i32) -> Buffer {
    let scan_buf = alloc_cpu(size * sizeof[i32]());
    let mut scan = bitcast[&[i32]](scan_buf.data);
    let     hist = bitcast[&[i32]](hist_buf.data);
    scan(0) = hist(0);
    for i in $range(1, size) {
        scan(i) = scan(i-1) + hist(i);
    }
    scan_buf
}
fn find_position(scan_buf: Buffer, size: i32, body: fn(i32) -> i32) -> i32 {
    let scan = bitcast[&[i32]](scan_buf.data);
    for i in $range(0, size) {
        if body(scan(i)) != 0 { return(i) }
    }
    size
}
