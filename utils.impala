fn range_step(lower: i32, upper: i32, step: i32, body: fn(i32, fn())) -> () {
    if lower < upper {
        body(lower);
        range_step(lower+step, upper, step, body, return)
    }
}

fn range_step_rev(upper: i32, lower: i32, step: i32, body: fn(i32, fn())) -> () {
    if upper > lower {
        body(upper);
        range_step_rev(upper-step, lower, step, body, return)
    }
}

fn range(lower: i32, upper: i32, body: fn(i32, fn())) -> () { range_step(lower, upper, 1, body) }
fn range_rev(upper: i32, lower: i32, body: fn(i32, fn())) -> () { range_step_rev(upper, lower, 1, body) }

fn force_unroll(a: i32, b: i32, body: fn(i32, fn())) -> () {
    if a < b {
        body(a);
        @force_unroll(a+1, b, body, return)
    }
}

fn range_times_two(lower: i32, upper: i32, body: fn(i32, fn())) -> () {
    if lower < upper {
        body(lower);
        range_times_two(lower*2, upper, body, return)
    }
}

fn init_zero(mut arr: &[f32], width: i32, height: i32) -> () {
    for i in $range(0, width*height) {
        arr(i) = 0.0f;
    }
}
fn init_rand(mut arr: &[f32], width: i32, height: i32) -> () {
    for y in $range(0, height) {
        for x in range(0, width) {
            arr(y*width + x) = thorin_random_val() * 1024f;
        }
    }
}

// border handling specialization
fn nobh_center (idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 { idx }
fn clamp_lower (idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx < lower { lower } else { idx }
}
fn clamp_upper (idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx >= upper { upper - 1 } else { idx }
}
fn mirror_lower(idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx < lower { lower + (lower - idx-1) } else { idx }
}
fn mirror_upper(idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx >= upper { upper - (idx+1 - upper) } else { idx }
}
fn repeat_lower(idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx < lower { idx + (lower + upper) } else { idx }
}
fn repeat_upper(idx: i32, lower: i32, upper: i32, out: fn(f32)) -> i32 {
    if idx >= upper { idx - (lower + upper) } else { idx }
}
fn const_lower (idx: i32, lower: i32, upper: i32, cval: f32, out: fn(f32)) -> i32 {
    if idx < lower { out(cval) } else { idx }
}
fn const_upper (idx: i32, lower: i32, upper: i32, cval: f32, out: fn(f32)) -> i32 {
    if idx >= upper { out(cval) } else { idx }
}
fn wrap_const_fun(fun: fn(i32, i32, i32, f32, fn(f32)) -> i32, cval: f32) -> fn(i32, i32, i32, fn(f32)) -> i32 {
    |idx, lower, upper, out| fun(idx, lower, upper, cval, out)
}
fn read_pixel(x: i32, y: i32, region: i32, roi: RoI, read: fn(i32, i32) -> f32,
              bh_lower: fn(i32, i32, i32, fn(f32)) -> i32,
              bh_upper: fn(i32, i32, i32, fn(f32)) -> i32
             ) -> f32 {
    let mut idx_x = roi.o_x + x;
    let mut idx_y = roi.o_y + y;

    let lower_x = roi.o_x;
    let lower_y = roi.o_y;
    let upper_x = roi.o_x + roi.width;
    let upper_y = roi.o_y + roi.height;

    // 0 --- 1 --- 2
    // 3 --- 4 --- 5
    // 6 --- 7 --- 8

    // left
    if region == 0 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }
    if region == 3 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }
    if region == 6 { idx_x = bh_lower(idx_x, lower_x, upper_x, return); }

    // right
    if region == 2 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }
    if region == 5 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }
    if region == 8 { idx_x = bh_upper(idx_x, lower_x, upper_x, return); }

    // top
    if region == 0 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }
    if region == 1 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }
    if region == 2 { idx_y = bh_lower(idx_y, lower_y, upper_y, return); }

    // bottom
    if region == 6 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }
    if region == 7 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }
    if region == 8 { idx_y = bh_upper(idx_y, lower_y, upper_y, return); }

    // all in
    if region == 10 {
        idx_x = bh_lower(idx_x, lower_x, upper_x, return);
        idx_x = bh_upper(idx_x, lower_x, upper_x, return);
        idx_y = bh_lower(idx_y, lower_y, upper_y, return);
        idx_y = bh_upper(idx_y, lower_y, upper_y, return);
    }

    read(idx_x, idx_y)
}

static mut total_overall_timing = 0i64;

static mut total_kernel_timing = 0i64;
static mut total_kernel_startup_timing = 0i64;

static mut total_cpu_timing = 0i64;

static mut total_hetero_timing = 0i64;

fn benchmark(get_time: fn() -> i64, num_iter: i32, body: fn() -> ()) -> (i64, i64) {
    let times_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut times = bitcast[&[i64]](times_buf.data);
    let overall_times_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut overall_times = bitcast[&[i64]](overall_times_buf.data);

    for i in $range(0, num_iter) @{
        let start_all = thorin_get_micro_time();
        let start = get_time();
        body();
        acc_sync(acc_dev());
        times(i) = get_time() - start;
        let finish = thorin_get_micro_time();
        let diff = finish - start_all;
        overall_times(i) = diff;
    }

    sort_i64(num_iter, bitcast[&[i64]](overall_times));

    print_string("Overall Timing (incl. all overheads): ");
    print_double(overall_times(num_iter/2) as f64 / 1000.0);
    print_string(" | ");
    print_double(overall_times(0) as f64 / 1000.0);
    print_string(" | ");
    print_double(overall_times(num_iter-1) as f64 / 1000.0);
    print_string(" (median(");
    print_int(num_iter);
    print_string(") | minimum | maximum) ms\n");

    sort_i64(num_iter, bitcast[&[i64]](times));
    print_string("Timing: ");
    print_double(times(num_iter/2) as f64 / 1000.0);
    print_string(" | ");
    print_double(times(0) as f64 / 1000.0);
    print_string(" | ");
    print_double(times(num_iter-1) as f64 / 1000.0);
    print_string(" (median(");
    print_int(num_iter);
    print_string(") | minimum | maximum) ms\n\n");

    let median = times(num_iter/2);
    let overall_median = overall_times(num_iter/2);
    release(times_buf);
    release(overall_times_buf);
    (median, overall_median)
}

fn benchmark_acc(body: fn() -> ()) -> () {
    let timing = benchmark(thorin_get_kernel_time, 7, body);
    total_hetero_timing += timing(0);
    total_kernel_timing += timing(0);
    total_overall_timing += timing(1);
}

fn benchmark_cpu(body: fn() -> ()) -> () {
    let timing = benchmark(thorin_get_micro_time, 27, body);
    total_hetero_timing += timing(0);
    total_cpu_timing += timing(0);
    total_overall_timing += timing(1);
}

fn benchmark_hetero(body_acc: fn() -> (), body_cpu: fn() -> ()) -> () {
    let num_iter = 27;

    let idxs_buf = alloc_cpu(num_iter * sizeof[i32]());
    let mut idxs =     bitcast[&[i32]](idxs_buf.data);

    let times_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut times =     bitcast[&[i64]](times_buf.data);

    let times_cpu_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut times_cpu = bitcast[&[i64]](times_cpu_buf.data);

    let prequeue_times_acc_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut prequeue_times_acc = bitcast[&[i64]](prequeue_times_acc_buf.data);
    let queue_times_acc_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut queue_times_acc = bitcast[&[i64]](queue_times_acc_buf.data);
    let startup_times_acc_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut startup_times_acc = bitcast[&[i64]](startup_times_acc_buf.data);
    let times_acc_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut times_acc = bitcast[&[i64]](times_acc_buf.data);
    let postqueue_times_acc_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut postqueue_times_acc = bitcast[&[i64]](postqueue_times_acc_buf.data);

    let overall_times_buf = alloc_cpu(num_iter * sizeof[i64]());
    let mut overall_times = bitcast[&[i64]](overall_times_buf.data);

    for i in $range(0, num_iter) @{
        let start = thorin_get_micro_time();
        let start_acc = thorin_get_kernel_time();
        let startup_start_acc = thorin_get_kernel_startup_time();
        let prequeue_start_acc = thorin_get_kernel_prequeue_time();
        let queue_start_acc = thorin_get_kernel_queue_time();
        let postqueue_start_acc = thorin_get_kernel_postqueue_time();

        let gpu_t = with spawn_thread() {
            body_acc();
            acc_sync(acc_dev());
        };

        let cpu_thread_start_delay = thorin_get_micro_time() - start;

        let cpu_t = with spawn_thread() {
            body_cpu();
        };

        sync_thread(cpu_t);
        let time_cpu = (thorin_get_micro_time() - start);

        sync_thread(gpu_t);
        let time_acc = thorin_get_kernel_time() - start_acc;
        let startup_time = thorin_get_kernel_startup_time() - startup_start_acc;
        let queue_time = thorin_get_kernel_queue_time() - queue_start_acc;
        let prequeue_time = thorin_get_kernel_prequeue_time() - prequeue_start_acc;
        let postqueue_time = thorin_get_kernel_postqueue_time() - postqueue_start_acc;

        let finish = thorin_get_micro_time();
        let diff = finish - start;

        overall_times(i) = diff;
        times(i) = max(time_acc, time_cpu);
        times_cpu(i) = time_cpu;
        times_acc(i) = time_acc;
        startup_times_acc(i) = startup_time;
        queue_times_acc(i) = queue_time;
        prequeue_times_acc(i) = prequeue_time;
        postqueue_times_acc(i) = postqueue_time;
    }

    sort_i64_with_idxs(num_iter, bitcast[&[i64]](times), idxs);
    let median_idx = idxs(num_iter/2);


    let median = times(num_iter/2);

    let median_startup = startup_times_acc(median_idx);
    let median_queue = queue_times_acc(median_idx);
    let median_prequeue = prequeue_times_acc(median_idx);
    let median_postqueue = postqueue_times_acc(median_idx);
    let median_overall = overall_times(median_idx);
    //sort_i64(num_iter, bitcast[&[i64]](times_cpu));
    let median_cpu = times_cpu(median_idx);

    //sort_i64(num_iter, bitcast[&[i64]](times_acc));
    let median_acc = times_acc(median_idx);

    let show_profile_info = false;

    if (show_profile_info) {
        let gap = median_overall - (median_prequeue + median_queue + median_startup + median + median_postqueue);
        let mut start = 0 as i64;
        print_profiling_entry("Set Kernel Args", start, median_prequeue, 0);
        print_profiling_entry("Execute CPU Part", start, median_cpu, 2);
        start += median_prequeue;
        print_profiling_entry("Enqueue Kernel", start, median_queue, 0);
        start += median_queue;
        print_profiling_entry("Submit Kernel", start, median_startup, 0);
        start += median_startup;
        print_profiling_entry("Execute Kernel", start, median_acc, 1);
        start += median_acc;
        print_profiling_entry("Gap", start, gap, 1);
        start += gap;
        print_profiling_entry("Gather Profile Info & Clean Up", start, median_postqueue, 0);
    }

    release(idxs_buf);
    release(times_buf);
    release(times_cpu_buf);
    release(times_acc_buf);
    release(startup_times_acc_buf);
    release(overall_times_buf);
    release(queue_times_acc_buf);
    release(prequeue_times_acc_buf);
    release(postqueue_times_acc_buf);

    total_hetero_timing += median;
    total_cpu_timing    += median_cpu;
    total_kernel_timing += median_acc;
    total_overall_timing += median_overall;
    total_kernel_startup_timing += median_startup;
}

fn print_profiling_entry(name: &[u8], start: i64, duration: i64, stream: i32) -> () {
    print_string(name);
    print_string(", ");
    print_long(start);
    print_string(", ");
    print_long(duration);
    print_string(", ");
    print_int(stream);
    print_string("\n");
}

fn print_timing_info(num_iter: i32, times: &[i64], name: &[u8]) -> () {
    print_string(name);
    print_string(": ");
    print_double(times(num_iter/2) as f64 / 1000.0);
    print_string(" | ");
    print_double(times(0) as f64 / 1000.0);
    print_string(" | ");
    print_double(times(num_iter-1) as f64 / 1000.0);
    print_string(" (median(");
    print_int(num_iter);
    print_string(") | minimum | maximum) ms\n");
}

fn max(x: i64, y: i64) -> i64 {
    if x > y { x } else { y }
}

fn min(x: i64, y: i64) -> i64 {
    if x < y { x } else { y }
}

fn print_total_timing() -> () {
    print_string("Total timing for cpu / kernel: ");
    print_double(total_cpu_timing as f64 / 1000.0);
    print_string(" / ");
    print_double(total_kernel_timing as f64 / 1000.0);
    print_string(" ms\n");

    print_string("Total overall timing (incl. all overheads): ");
    print_double(total_overall_timing as f64 / 1000.0);
    print_string(" ms\n");
}

fn sort_i64(num: i32, mut arr: &[i64]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}

fn sort_i64_with_idxs(num: i32, mut arr: &[i64], mut idx_arr: &[i32]) -> () {

    for i in range(0, num) {
        idx_arr(i) = i;
    }

    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let x_idx = idx_arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            idx_arr(j) = idx_arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
        idx_arr(j) = x_idx;
    }
}

fn sort_f32(num: i32, mut arr: &[f32]) -> () {
    // insertion sort
    for i in range(1, num) {
        let x = arr(i);
        let mut j = i;
        while j > 0 && arr(j-1) > x {
            arr(j) = arr(j-1);
            j = j - 1;
        }
        arr(j) = x;
    }
}

// nearest multiple of num
fn round_up(num: i32, multiple: i32) -> i32 { ((num + multiple - 1) / multiple) * multiple }


// &[1][f32]
fn get_pixel_as1(img: Img, idx: i32) -> f32 { bitcast[&[1][f32]](img.buf.data)(idx) }
fn get_pixel_ldg(img: Img, idx: i32) -> f32 { let mut ptr = bitcast[&[1][f32]](img.buf.data); ldg_f32(bitcast[&[1]f32](&ptr(idx))) }
fn set_pixel_as1(img: Img, idx: i32, val: f32) -> () { let mut ptr = bitcast[&[1][f32]](img.buf.data); ptr(idx) = val }
fn get_acc_bh(img: Img, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    get_acc_bh_offset(img, 0, 0, region, bh_lower, bh_upper)
}
fn get_acc_bh_offset(img: Img, rox: i32, roy: i32, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    get_acc_asx_bh_offset(img, rox, roy, region, bh_lower, bh_upper, get_pixel_as1)
}
fn get_acc_tex_bh(img: Img, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    get_acc_tex_bh_offset(img, 0, 0, region, bh_lower, bh_upper)
}
fn get_acc_tex_bh_offset(img: Img, rox: i32, roy: i32, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    get_acc_asx_bh_offset(img, rox, roy, region, bh_lower, bh_upper, get_pixel_ldg)
}
fn get_acc_asx_bh_offset(img: Img, rox: i32, roy: i32, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32, get_pixel_asx: fn(Img, i32) -> f32) -> Acc {
    Acc {
        read  : |x, y|    -> f32 { read_pixel(x + rox, y + roy, region, RoI { o_x : 0, o_y : 0, width : img.width, height : img.height }, |x, y| -> f32 { get_pixel_asx(img, y * img.stride + x) }, bh_lower, bh_upper) },
        write : |x, y, v| -> ()  { set_pixel_as1(img, (y + roy) * img.stride + x + rox, v) }
    }
}
fn get_acc(img: Img) -> Acc {
    get_acc_offset(img, 0, 0)
}
fn get_acc_offset(img: Img, rox: i32, roy: i32) -> Acc {
    get_acc_asx_offset(img, rox, roy, get_pixel_as1)
}
fn get_acc_tex(img: Img) -> Acc {
    get_acc_tex_offset(img, 0, 0)
}
fn get_acc_tex_offset(img: Img, rox: i32, roy: i32) -> Acc {
    get_acc_asx_offset(img, rox, roy, get_pixel_ldg)
}
fn get_acc_asx_offset(img: Img, rox: i32, roy: i32, get_pixel_asx: fn(Img, i32) -> f32) -> Acc {
    Acc {
        read  : |x, y|    get_pixel_asx(img, (y + roy) * img.stride + x + rox),
        write : |x, y, v| set_pixel_as1(img, (y + roy) * img.stride + x + rox, v)
    }
}
fn get_img(buf: Buffer, width: i32, height: i32) -> Img {
    Img { buf : buf, width : width,  height : height, stride : width }
}

// &[0][f32]
fn get_pixel_as0(data: &[f32], idx: i32) -> f32 { data(idx) }
fn set_pixel_as0(mut data: &[f32], idx: i32, val: f32) -> () { data(idx) = val }
fn get_acc_bh_memory(data: &[f32], width: i32, height: i32, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    get_acc_bh_offset_memory(data, width, height, 0, 0, region, bh_lower, bh_upper)
}
fn get_acc_bh_offset_memory(data: &[f32], width: i32, height: i32, rox: i32, roy: i32, region: i32, bh_lower: fn(i32, i32, i32, fn(f32)) -> i32, bh_upper: fn(i32, i32, i32, fn(f32)) -> i32) -> Acc {
    Acc {
        read  : |x, y|    -> f32 { read_pixel(x + rox, y + roy, region, RoI { o_x : 0, o_y : 0, width : width, height : height }, |x, y| -> f32 { get_pixel_as0(data, y * width + x) }, bh_lower, bh_upper) },
        write : |x, y, v| -> ()  { set_pixel_as0(data, (y + roy) * width + x + rox, v) }
    }
}
fn get_acc_memory(data: &[f32], width: i32, height: i32) -> Acc {
    get_acc_offset_memory(data, width, height, 0, 0)
}
fn get_acc_offset_memory(data: &[f32], width: i32, height: i32, rox: i32, roy: i32) -> Acc {
    Acc {
        read  : |x, y|    get_pixel_as0(data, (y + roy) * width + x + rox),
        write : |x, y, v| set_pixel_as0(data, (y + roy) * width + x + rox, v)
    }
}

// &[3][f32]
fn get_pixel_as3(data: &[3][f32], idx: i32) -> f32 { data(idx) }
fn set_pixel_as3(mut data: &[3][f32], idx: i32, val: f32) -> () { data(idx) = val }
fn get_acc_shared(data: &[3][f32], width: i32, height: i32) -> Acc {
    get_acc_offset_shared(data, width, height, 0, 0)
}
fn get_acc_offset_shared(data: &[3][f32], width: i32, height: i32, rox: i32, roy: i32) -> Acc {
    Acc {
        read  : |x, y|    get_pixel_as3(data, (y + roy) * width + x + rox),
        write : |x, y, v| set_pixel_as3(data, (y + roy) * width + x + rox, v)
    }
}

// structs for images and accessors
struct Img {
    buf : Buffer,
    width  : i32,
    height : i32,
    stride : i32,
}
struct RoI {
    o_x : i32,
    o_y : i32,
    width : i32,
    height : i32
}
struct Acc {
    read  : fn(i32, i32) -> f32,
    write : fn(i32, i32, f32) -> (),
}
struct Mask3 {
    data : [[f32 * 3] * 3],
    size_x : i32,
    size_y : i32,
}
struct Mask3Sep {
    data : [f32 * 3],
    size : i32,
}
struct Mask5 {
    data : [[f32 * 5] * 5],
    size_x : i32,
    size_y : i32,
}
struct Mask5Sep {
    data : [f32 * 5],
    size : i32,
}
